import sqlite3 from 'sqlite3';
import { promisify } from 'util';
import { fileURLToPath } from 'url';
import { dirname, join } from 'path';
import { existsSync, mkdirSync, writeFileSync, unlinkSync } from 'fs';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// Êï∞ÊçÆÂ∫ìÊñá‰ª∂Ë∑ØÂæÑ - Â≠òÂÇ®Âú® /app/data ÁõÆÂΩï‰ª•ÂÆûÁé∞Êï∞ÊçÆÊåÅ‰πÖÂåñ
const DB_PATH = process.env.DATABASE_PATH || join(__dirname, '..', 'data', 'domains.db');

class DomainDatabase {
  constructor() {
    this.db = null;
  }

  // ÂàùÂßãÂåñÊï∞ÊçÆÂ∫ìËøûÊé•
  async init() {
    return new Promise((resolve, reject) => {
      // Á°Æ‰øùÊï∞ÊçÆÁõÆÂΩïÂ≠òÂú®
      const dataDir = dirname(DB_PATH);
      console.log(`üîç Êï∞ÊçÆÂ∫ìË∑ØÂæÑ: ${DB_PATH}`);
      console.log(`üîç Êï∞ÊçÆÁõÆÂΩï: ${dataDir}`);
      
      if (!existsSync(dataDir)) {
        try {
          mkdirSync(dataDir, { recursive: true });
          console.log(`‚úÖ Êï∞ÊçÆÁõÆÂΩïÂàõÂª∫ÊàêÂäü: ${dataDir}`);
        } catch (err) {
          console.error(`‚ùå Êï∞ÊçÆÁõÆÂΩïÂàõÂª∫Â§±Ë¥•: ${err.message}`);
          console.error(`üìã ÈîôËØØËØ¶ÊÉÖ: ${err.stack}`);
          reject(err);
          return;
        }
      } else {
        console.log(`‚úÖ Êï∞ÊçÆÁõÆÂΩïÂ∑≤Â≠òÂú®: ${dataDir}`);
      }

      // Ê£ÄÊü•ÁõÆÂΩïÊùÉÈôê
      try {
        // Â∞ùËØïÂÜôÂÖ•ÊµãËØïÊñá‰ª∂Êù•Ê£ÄÊü•ÊùÉÈôê
        const testFile = join(dataDir, '.write-test');
        writeFileSync(testFile, 'test');
        unlinkSync(testFile);
        console.log(`‚úÖ Êï∞ÊçÆÁõÆÂΩïÊùÉÈôêÊ≠£Â∏∏: ${dataDir}`);
      } catch (err) {
        console.error(`‚ùå Êï∞ÊçÆÁõÆÂΩïÊùÉÈôê‰∏çË∂≥: ${err.message}`);
        console.error(`üîß ËØ∑Ê£ÄÊü•ÁõÆÂΩïÊùÉÈôê: ls -la ${dirname(dataDir)}`);
        reject(new Error(`Êï∞ÊçÆÁõÆÂΩïÊùÉÈôê‰∏çË∂≥: ${dataDir} - ${err.message}`));
        return;
      }

      this.db = new sqlite3.Database(DB_PATH, (err) => {
        if (err) {
          console.error('‚ùå Êï∞ÊçÆÂ∫ìËøûÊé•Â§±Ë¥•:', err.message);
          console.error('üìã ÈîôËØØ‰ª£Á†Å:', err.code || 'UNKNOWN');
          console.error('üìã ÈîôËØØÁºñÂè∑:', err.errno || 'UNKNOWN');
          console.error('üîß Âª∫ËÆÆËß£ÂÜ≥ÊñπÊ°à:');
          console.error('   1. Ê£ÄÊü•Êï∞ÊçÆÁõÆÂΩïÊùÉÈôê: ls -la /app/data');
          console.error('   2. Ê£ÄÊü•Á£ÅÁõòÁ©∫Èó¥: df -h');
          console.error('   3. Ê£ÄÊü•Áî®Êà∑ÊùÉÈôê: whoami && id');
          reject(err);
        } else {
          console.log('‚úÖ SQLiteÊï∞ÊçÆÂ∫ìËøûÊé•ÊàêÂäü');
          console.log(`üìç Êï∞ÊçÆÂ∫ìÊñá‰ª∂‰ΩçÁΩÆ: ${DB_PATH}`);
          
          this.db.serialize(async () => {
            try {
              // ÂàõÂª∫Âü∫Á°ÄË°®
              await this.createTable();
              
              // ËøÅÁßªÊï∞ÊçÆÂ∫ìË°®ÁªìÊûÑÔºàÊ∑ªÂä†Êñ∞Â≠óÊÆµÔºâ
              await this.migrateDatabase();
              
              // ÂàùÂßãÂåñËÆ§ËØÅÈÖçÁΩÆ
              await this.initializeAuthConfig();
              
              resolve();
            } catch (error) {
              console.error('Êï∞ÊçÆÂ∫ìÂàùÂßãÂåñÂ§±Ë¥•:', error);
              reject(error);
            }
          });
        }
      });
    });
  }

  // Êï∞ÊçÆÂ∫ìË°®ÁªìÊûÑËøÅÁßª
  async migrateDatabase() {
    return new Promise(async (resolve, reject) => {
      try {
        const alterStatements = [];

        // Ê£ÄÊü•domainsË°®ÁöÑÊñ∞Â≠óÊÆµ
        await new Promise((resolveCheck, rejectCheck) => {
          this.db.all("PRAGMA table_info(domains)", (err, columns) => {
            if (err) {
              rejectCheck(err);
              return;
            }

            const columnNames = columns.map(col => col.name);
            
            if (!columnNames.includes('isImportant')) {
              alterStatements.push('ALTER TABLE domains ADD COLUMN isImportant BOOLEAN DEFAULT 0');
            }
            
            if (!columnNames.includes('notes')) {
              alterStatements.push('ALTER TABLE domains ADD COLUMN notes TEXT');
            }

            resolveCheck();
          });
        });

        // Ê£ÄÊü•notification_rulesË°®ÊòØÂê¶ÊúâÊñ∞ÁöÑË∞ÉÂ∫¶Â≠óÊÆµ
        await new Promise((resolveCheck, rejectCheck) => {
          this.db.all("PRAGMA table_info(notification_rules)", (err, columns) => {
            if (err) {
              rejectCheck(err);
              return;
            }

            const columnNames = columns.map(col => col.name);
            
            if (!columnNames.includes('scheduleHour')) {
              alterStatements.push('ALTER TABLE notification_rules ADD COLUMN scheduleHour INTEGER DEFAULT 8');
            }
            
            if (!columnNames.includes('scheduleMinute')) {
              alterStatements.push('ALTER TABLE notification_rules ADD COLUMN scheduleMinute INTEGER DEFAULT 0');
            }
            
            if (!columnNames.includes('scheduleWeekday')) {
              alterStatements.push('ALTER TABLE notification_rules ADD COLUMN scheduleWeekday INTEGER');
            }
            
            if (!columnNames.includes('cronExpression')) {
              alterStatements.push('ALTER TABLE notification_rules ADD COLUMN cronExpression TEXT');
            }

            resolveCheck();
          });
        });

        if (alterStatements.length > 0) {
          console.log('üîÑ Ê£ÄÊµãÂà∞Êï∞ÊçÆÂ∫ìË°®ÁªìÊûÑÊõ¥Êñ∞ÔºåÂºÄÂßãËøÅÁßª...');
          
          // ÊâßË°åÊâÄÊúâALTERËØ≠Âè•
          let completedCount = 0;
          const totalCount = alterStatements.length;

          for (const statement of alterStatements) {
            await new Promise((resolveAlter, rejectAlter) => {
              this.db.run(statement, (err) => {
                if (err) {
                  console.error(`Ë°®ÁªìÊûÑÊõ¥Êñ∞Â§±Ë¥•:`, err);
                  rejectAlter(err);
                  return;
                }

                completedCount++;
                console.log(`‚úÖ Â≠óÊÆµÊõ¥Êñ∞ ${completedCount}/${totalCount} ÂÆåÊàê`);
                resolveAlter();
              });
            });
          }

          // ÊâÄÊúâÂ≠óÊÆµÊ∑ªÂä†ÂÆåÊàêÔºåÊõ¥Êñ∞Áé∞ÊúâËÆ∞ÂΩïÁöÑcronË°®ËææÂºè
          await this.updateExistingRulesCron();
          console.log('‚úÖ Êï∞ÊçÆÂ∫ìË°®ÁªìÊûÑËøÅÁßªÂÆåÊàê');
        } else {
          console.log('‚úÖ Êï∞ÊçÆÂ∫ìË°®ÁªìÊûÑÂ∑≤ÊòØÊúÄÊñ∞ÁâàÊú¨');
        }

        resolve();
      } catch (error) {
        console.error('Êï∞ÊçÆÂ∫ìËøÅÁßªÂ§±Ë¥•:', error);
        reject(error);
      }
    });
  }

  // Êõ¥Êñ∞Áé∞ÊúâËßÑÂàôÁöÑcronË°®ËææÂºè
  async updateExistingRulesCron() {
    return new Promise((resolve, reject) => {
      // Ëé∑ÂèñÊâÄÊúâÊ≤°ÊúâcronË°®ËææÂºèÁöÑËßÑÂàô
      const selectSQL = `
        SELECT id, type, scheduleHour, scheduleMinute, scheduleWeekday 
        FROM notification_rules 
        WHERE cronExpression IS NULL OR cronExpression = ''
      `;

      this.db.all(selectSQL, (err, rules) => {
        if (err) {
          reject(err);
          return;
        }

        if (rules.length === 0) {
          resolve();
          return;
        }

        console.log(`üîÑ Êõ¥Êñ∞ ${rules.length} ‰∏™Áé∞ÊúâËßÑÂàôÁöÑcronË°®ËææÂºè...`);

        let completedCount = 0;
        rules.forEach(rule => {
          const cronExpression = this.generateCronExpression(
            rule.type,
            rule.scheduleHour || 8,
            rule.scheduleMinute || 0,
            rule.scheduleWeekday || 1
          );

          const updateSQL = 'UPDATE notification_rules SET cronExpression = ? WHERE id = ?';
          
          this.db.run(updateSQL, [cronExpression, rule.id], (err) => {
            if (err) {
              console.error(`Êõ¥Êñ∞ËßÑÂàô ${rule.id} ÁöÑcronË°®ËææÂºèÂ§±Ë¥•:`, err);
            } else {
              console.log(`‚úÖ Êõ¥Êñ∞ËßÑÂàô ${rule.id} ÁöÑcronË°®ËææÂºè: ${cronExpression}`);
            }

            completedCount++;
            if (completedCount === rules.length) {
              resolve();
            }
          });
        });
      });
    });
  }

  // ÂàõÂª∫domainsË°®ÂíåÂàÜÁªÑÁõ∏ÂÖ≥Ë°®
  async createTable() {
    const createDomainsTableSQL = `
      CREATE TABLE IF NOT EXISTS domains (
        id TEXT PRIMARY KEY,
        domain TEXT UNIQUE NOT NULL,
        registrar TEXT,
        expiresAt TEXT,
        dnsProvider TEXT,
        domainStatus TEXT,
        status TEXT DEFAULT 'normal' CHECK(status IN ('normal', 'expiring', 'expired', 'failed', 'unregistered')),
        lastCheck TEXT,
        isImportant BOOLEAN DEFAULT 0,
        notes TEXT,
        createdAt TEXT NOT NULL,
        updatedAt TEXT NOT NULL
      )
    `;

    const createGroupsTableSQL = `
      CREATE TABLE IF NOT EXISTS groups (
        id TEXT PRIMARY KEY,
        name TEXT UNIQUE NOT NULL,
        description TEXT,
        color TEXT DEFAULT '#3B82F6',
        createdAt TEXT NOT NULL,
        updatedAt TEXT NOT NULL
      )
    `;

    const createDomainGroupsTableSQL = `
      CREATE TABLE IF NOT EXISTS domain_groups (
        id TEXT PRIMARY KEY,
        domainId TEXT NOT NULL,
        groupId TEXT NOT NULL,
        createdAt TEXT NOT NULL,
        FOREIGN KEY (domainId) REFERENCES domains (id) ON DELETE CASCADE,
        FOREIGN KEY (groupId) REFERENCES groups (id) ON DELETE CASCADE,
        UNIQUE(domainId, groupId)
      )
    `;

    // ÈÇÆ‰ª∂ÈÖçÁΩÆË°®
    const createEmailConfigsTableSQL = `
      CREATE TABLE IF NOT EXISTS email_configs (
        id TEXT PRIMARY KEY,
        name TEXT NOT NULL,
        host TEXT NOT NULL,
        port INTEGER NOT NULL,
        secure BOOLEAN DEFAULT 1,
        username TEXT NOT NULL,
        password TEXT NOT NULL,
        fromEmail TEXT NOT NULL,
        fromName TEXT,
        isDefault BOOLEAN DEFAULT 0,
        isActive BOOLEAN DEFAULT 1,
        createdAt TEXT NOT NULL,
        updatedAt TEXT NOT NULL
      )
    `;

    // ÈÇÆ‰ª∂Ê®°ÊùøË°®
    const createEmailTemplatesTableSQL = `
      CREATE TABLE IF NOT EXISTS email_templates (
        id TEXT PRIMARY KEY,
        name TEXT NOT NULL,
        type TEXT NOT NULL CHECK(type IN ('reminder', 'summary')),
        language TEXT NOT NULL DEFAULT 'zh' CHECK(language IN ('zh', 'en')),
        subject TEXT NOT NULL,
        htmlContent TEXT NOT NULL,
        textContent TEXT,
        variables TEXT, -- JSONÊ†ºÂºèÂ≠òÂÇ®ÂèØÁî®ÂèòÈáè
        isDefault BOOLEAN DEFAULT 0,
        isActive BOOLEAN DEFAULT 1,
        createdAt TEXT NOT NULL,
        updatedAt TEXT NOT NULL
      )
    `;

    // ÈÄöÁü•ËßÑÂàôË°®
    const createNotificationRulesTableSQL = `
      CREATE TABLE IF NOT EXISTS notification_rules (
        id TEXT PRIMARY KEY,
        name TEXT NOT NULL,
        type TEXT NOT NULL CHECK(type IN ('expiry_reminder', 'daily_summary', 'weekly_summary')),
        days INTEGER, -- ÊèêÈÜíÂ§©Êï∞ÔºàÂà∞ÊúüÊèêÈÜíÔºöÊ≠£Êï∞=Âà∞ÊúüÂâçÔºåË¥üÊï∞=Âà∞ÊúüÂêéÔºâ
        scheduleHour INTEGER DEFAULT 8, -- ÂèëÈÄÅÂ∞èÊó∂Ôºà0-23Ôºâ
        scheduleMinute INTEGER DEFAULT 0, -- ÂèëÈÄÅÂàÜÈíüÔºà0-59Ôºâ
        scheduleWeekday INTEGER, -- Âë®Âá†ÂèëÈÄÅÔºàweekly_summaryÔºö0=Âë®Êó•Ôºå1=Âë®‰∏Ä...6=Âë®ÂÖ≠Ôºâ
        cronExpression TEXT, -- Ëá™Âä®ÁîüÊàêÁöÑcronË°®ËææÂºè
        isActive BOOLEAN DEFAULT 1,
        emailConfigId TEXT,
        templateId TEXT,
        recipients TEXT NOT NULL, -- JSONÊ†ºÂºèÂ≠òÂÇ®ÈÇÆ‰ª∂Êé•Êî∂ËÄÖÂàóË°®
        lastRun TEXT,
        nextRun TEXT,
        runCount INTEGER DEFAULT 0,
        createdAt TEXT NOT NULL,
        updatedAt TEXT NOT NULL,
        FOREIGN KEY (emailConfigId) REFERENCES email_configs (id) ON DELETE SET NULL,
        FOREIGN KEY (templateId) REFERENCES email_templates (id) ON DELETE SET NULL
      )
    `;

    // ÈÄöÁü•ËÆ∞ÂΩïË°®
    const createNotificationLogsTableSQL = `
      CREATE TABLE IF NOT EXISTS notification_logs (
        id TEXT PRIMARY KEY,
        ruleId TEXT NOT NULL,
        domainIds TEXT, -- JSONÊ†ºÂºèÂ≠òÂÇ®Áõ∏ÂÖ≥ÂüüÂêçIDÂàóË°®
        recipient TEXT NOT NULL,
        subject TEXT NOT NULL,
        status TEXT NOT NULL CHECK(status IN ('pending', 'sent', 'failed', 'retry')),
        errorMessage TEXT,
        sentAt TEXT,
        retryCount INTEGER DEFAULT 0,
        createdAt TEXT NOT NULL,
        FOREIGN KEY (ruleId) REFERENCES notification_rules (id) ON DELETE CASCADE
      )
    `;

    // ËÆ§ËØÅÈÖçÁΩÆË°® - Â≠òÂÇ®ËÆøÈóÆÂØÜÁ†ÅÁ≠âÈÖçÁΩÆ
    this.db.run(`
      CREATE TABLE IF NOT EXISTS auth_config (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        key TEXT UNIQUE NOT NULL,
        value TEXT NOT NULL,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
      )
    `, (err) => {
      if (err) {
        console.error('‚ùå auth_configË°®ÂàõÂª∫Â§±Ë¥•:', err.message);
      } else {
        console.log('‚úÖ auth_configË°®ÂàõÂª∫ÊàêÂäü');
      }
    });

    // ‰ºöËØùË°® - Â≠òÂÇ®Áî®Êà∑ÁôªÂΩï‰ºöËØù
    this.db.run(`
      CREATE TABLE IF NOT EXISTS auth_sessions (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        session_id TEXT UNIQUE NOT NULL,
        ip_address TEXT NOT NULL,
        user_agent TEXT,
        expires_at DATETIME NOT NULL,
        created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
        last_activity DATETIME DEFAULT CURRENT_TIMESTAMP
      )
    `, (err) => {
      if (err) {
        console.error('‚ùå auth_sessionsË°®ÂàõÂª∫Â§±Ë¥•:', err.message);
      } else {
        console.log('‚úÖ auth_sessionsË°®ÂàõÂª∫ÊàêÂäü');
      }
    });

    // ÁôªÂΩïÂ∞ùËØïËÆ∞ÂΩïË°® - Èò≤Êö¥ÂäõÁ†¥Ëß£
    this.db.run(`
      CREATE TABLE IF NOT EXISTS login_attempts (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        ip_address TEXT NOT NULL,
        success BOOLEAN NOT NULL DEFAULT 0,
        captcha_required BOOLEAN NOT NULL DEFAULT 0,
        attempt_time DATETIME DEFAULT CURRENT_TIMESTAMP
      )
    `, (err) => {
      if (err) {
        console.error('‚ùå login_attemptsË°®ÂàõÂª∫Â§±Ë¥•:', err.message);
      } else {
        console.log('‚úÖ login_attemptsË°®ÂàõÂª∫ÊàêÂäü');
      }
    });

    return new Promise((resolve, reject) => {
      // ÂàõÂª∫domainsË°®
      this.db.run(createDomainsTableSQL, (err) => {
        if (err) {
          console.error('ÂàõÂª∫domainsË°®Â§±Ë¥•:', err.message);
          reject(err);
          return;
        }
        console.log('‚úÖ domainsË°®ÂàõÂª∫ÊàêÂäü');

        // ÂàõÂª∫groupsË°®
        this.db.run(createGroupsTableSQL, (err) => {
          if (err) {
            console.error('ÂàõÂª∫groupsË°®Â§±Ë¥•:', err.message);
            reject(err);
            return;
          }
          console.log('‚úÖ groupsË°®ÂàõÂª∫ÊàêÂäü');

          // ÂàõÂª∫domain_groupsÂÖ≥ËÅîË°®
          this.db.run(createDomainGroupsTableSQL, (err) => {
            if (err) {
              console.error('ÂàõÂª∫domain_groupsË°®Â§±Ë¥•:', err.message);
              reject(err);
              return;
            }
            console.log('‚úÖ domain_groupsË°®ÂàõÂª∫ÊàêÂäü');
            
            // ÂàõÂª∫email_configsË°®
            this.db.run(createEmailConfigsTableSQL, (err) => {
              if (err) {
                console.error('ÂàõÂª∫email_configsË°®Â§±Ë¥•:', err.message);
                reject(err);
                return;
              }
              console.log('‚úÖ email_configsË°®ÂàõÂª∫ÊàêÂäü');
              
              // ÂàõÂª∫email_templatesË°®
              this.db.run(createEmailTemplatesTableSQL, (err) => {
                if (err) {
                  console.error('ÂàõÂª∫email_templatesË°®Â§±Ë¥•:', err.message);
                  reject(err);
                  return;
                }
                console.log('‚úÖ email_templatesË°®ÂàõÂª∫ÊàêÂäü');
                
                // ÂàõÂª∫notification_rulesË°®
                this.db.run(createNotificationRulesTableSQL, (err) => {
                  if (err) {
                    console.error('ÂàõÂª∫notification_rulesË°®Â§±Ë¥•:', err.message);
                    reject(err);
                    return;
                  }
                  console.log('‚úÖ notification_rulesË°®ÂàõÂª∫ÊàêÂäü');
                  
                  // ÂàõÂª∫notification_logsË°®
                  this.db.run(createNotificationLogsTableSQL, (err) => {
                    if (err) {
                      console.error('ÂàõÂª∫notification_logsË°®Â§±Ë¥•:', err.message);
                      reject(err);
                      return;
                    }
                    console.log('‚úÖ notification_logsË°®ÂàõÂª∫ÊàêÂäü');
                    
                    // ÂàõÂª∫ÈªòËÆ§ÂàÜÁªÑÂíåÈªòËÆ§ÈÇÆ‰ª∂ÈÖçÁΩÆ
                    this.createDefaultGroups()
                      .then(() => this.createDefaultEmailTemplates())
                      .then(resolve)
                      .catch(reject);
                  });
                });
              });
            });
          });
        });
      });
    });
  }

  // ÂàõÂª∫ÈªòËÆ§ÂàÜÁªÑ
  async createDefaultGroups() {
    const defaultGroups = [
      {
        id: 'default',
        name: 'ÈªòËÆ§ÂàÜÁªÑ',
        description: 'Êú™ÂàÜÁªÑÁöÑÂüüÂêç',
        color: '#6B7280'
      },
      {
        id: 'important',
        name: 'ÈáçË¶ÅÂüüÂêç',
        description: 'Ê†∏ÂøÉ‰∏öÂä°ÂüüÂêç',
        color: '#EF4444'
      },
      {
        id: 'development',
        name: 'ÂºÄÂèëÊµãËØï',
        description: 'ÂºÄÂèëÂíåÊµãËØïÁéØÂ¢ÉÂüüÂêç',
        color: '#10B981'
      }
    ];

    for (const group of defaultGroups) {
      await this.addGroupIfNotExists(group);
    }
  }

  // Ê∑ªÂä†ÂàÜÁªÑÔºàÂ¶ÇÊûú‰∏çÂ≠òÂú®Ôºâ
  async addGroupIfNotExists(groupData) {
    const { id, name, description, color } = groupData;
    const now = new Date().toISOString();

    const insertSQL = `
      INSERT OR IGNORE INTO groups (id, name, description, color, createdAt, updatedAt)
      VALUES (?, ?, ?, ?, ?, ?)
    `;

    return new Promise((resolve, reject) => {
      this.db.run(insertSQL, [id, name, description, color, now, now], function(err) {
        if (err) {
          console.error('ÂàõÂª∫ÈªòËÆ§ÂàÜÁªÑÂ§±Ë¥•:', err.message);
          reject(err);
        } else {
          if (this.changes > 0) {
            console.log(`‚úÖ ÈªòËÆ§ÂàÜÁªÑ"${name}"ÂàõÂª∫ÊàêÂäü`);
          }
          resolve();
        }
      });
    });
  }

  // ÂàõÂª∫ÈªòËÆ§ÈÇÆ‰ª∂Ê®°Êùø
  async createDefaultEmailTemplates() {
    const defaultTemplates = [
      {
        id: 'reminder_zh_7days',
        name: '7Â§©Âà∞ÊúüÊèêÈÜíÔºà‰∏≠ÊñáÔºâ',
        type: 'reminder',
        language: 'zh',
        subject: 'ÂüüÂêçÂà∞ÊúüÊèêÈÜí - {{domain}} Â∞Ü‰∫é {{days}} Â§©ÂêéÂà∞Êúü',
        htmlContent: `
          <!DOCTYPE html>
          <html>
          <head>
            <meta charset="utf-8">
            <style>
              .email-container { max-width: 600px; margin: 0 auto; font-family: Arial, sans-serif; }
              .header { background: #3B82F6; color: white; padding: 20px; text-align: center; }
              .content { padding: 20px; background: #f9fafb; }
              .domain-info { background: white; padding: 15px; margin: 10px 0; border-radius: 6px; }
              .warning { color: #EF4444; font-weight: bold; }
            </style>
          </head>
          <body>
            <div class="email-container">
              <div class="header">
                <h1>DomMate ÂüüÂêçÂà∞ÊúüÊèêÈÜí</h1>
              </div>
              <div class="content">
                <p>ÊÇ®Â•ΩÔºå</p>
                <p class="warning">ÊÇ®ÁöÑÂüüÂêçÂç≥Â∞ÜÂà∞ÊúüÔºåËØ∑ÂèäÊó∂Áª≠Ë¥πÔºÅ</p>
                <div class="domain-info">
                  <h3>ÂüüÂêç‰ø°ÊÅØ</h3>
                  <p><strong>ÂüüÂêç:</strong> {{domain}}</p>
                  <p><strong>Ê≥®ÂÜåÂïÜ:</strong> {{registrar}}</p>
                  <p><strong>Âà∞ÊúüÊó∂Èó¥:</strong> {{expiryDate}}</p>
                  <p><strong>Ââ©‰ΩôÂ§©Êï∞:</strong> <span class="warning">{{days}} Â§©</span></p>
                </div>
                <p>ËØ∑Â∞ΩÂø´ÁôªÂΩïÊ≥®ÂÜåÂïÜÁª≠Ë¥πÊÇ®ÁöÑÂüüÂêçÔºåÈÅøÂÖç‰∏öÂä°‰∏≠Êñ≠„ÄÇ</p>
              </div>
            </div>
          </body>
          </html>
        `,
        textContent: 'ÂüüÂêçÂà∞ÊúüÊèêÈÜí\n\nÊÇ®ÁöÑÂüüÂêç {{domain}} Â∞Ü‰∫é {{days}} Â§©ÂêéÂà∞ÊúüÔºåËØ∑ÂèäÊó∂Áª≠Ë¥π„ÄÇ\n\nÂüüÂêç‰ø°ÊÅØÔºö\n- ÂüüÂêç: {{domain}}\n- Ê≥®ÂÜåÂïÜ: {{registrar}}\n- Âà∞ÊúüÊó∂Èó¥: {{expiryDate}}\n- Ââ©‰ΩôÂ§©Êï∞: {{days}} Â§©',
        variables: JSON.stringify(['domain', 'registrar', 'expiryDate', 'days']),
        isDefault: true,
        isActive: true
      },
      {
        id: 'reminder_en_7days',
        name: '7-Day Expiry Reminder (English)',
        type: 'reminder',
        language: 'en',
        subject: 'Domain Expiry Notice - {{domain}} expires in {{days}} days',
        htmlContent: `
          <!DOCTYPE html>
          <html>
          <head>
            <meta charset="utf-8">
            <style>
              .email-container { max-width: 600px; margin: 0 auto; font-family: Arial, sans-serif; }
              .header { background: #3B82F6; color: white; padding: 20px; text-align: center; }
              .content { padding: 20px; background: #f9fafb; }
              .domain-info { background: white; padding: 15px; margin: 10px 0; border-radius: 6px; }
              .warning { color: #EF4444; font-weight: bold; }
            </style>
          </head>
          <body>
            <div class="email-container">
              <div class="header">
                <h1>DomMate Domain Expiry Notice</h1>
              </div>
              <div class="content">
                <p>Hello,</p>
                <p class="warning">Your domain is about to expire. Please renew it soon!</p>
                <div class="domain-info">
                  <h3>Domain Information</h3>
                  <p><strong>Domain:</strong> {{domain}}</p>
                  <p><strong>Registrar:</strong> {{registrar}}</p>
                  <p><strong>Expiry Date:</strong> {{expiryDate}}</p>
                  <p><strong>Days Remaining:</strong> <span class="warning">{{days}} days</span></p>
                </div>
                <p>Please login to your registrar to renew your domain as soon as possible.</p>
              </div>
            </div>
          </body>
          </html>
        `,
        textContent: 'Domain Expiry Notice\n\nYour domain {{domain}} expires in {{days}} days. Please renew it soon.\n\nDomain Information:\n- Domain: {{domain}}\n- Registrar: {{registrar}}\n- Expiry Date: {{expiryDate}}\n- Days Remaining: {{days}} days',
        variables: JSON.stringify(['domain', 'registrar', 'expiryDate', 'days']),
        isDefault: true,
        isActive: true
      },
      {
        id: 'summary_zh_daily',
        name: 'ÊØèÊó•Ê±áÊÄªÊä•ÂëäÔºà‰∏≠ÊñáÔºâ',
        type: 'summary',
        language: 'zh',
        subject: 'DomMate ÂüüÂêçÁõëÊéßÊó•Êä• - {{date}}',
        htmlContent: `
          <!DOCTYPE html>
          <html>
          <head>
            <meta charset="utf-8">
            <style>
              .email-container { max-width: 600px; margin: 0 auto; font-family: Arial, sans-serif; }
              .header { background: #3B82F6; color: white; padding: 20px; text-align: center; }
              .content { padding: 20px; background: #f9fafb; }
              .stats { display: flex; justify-content: space-around; margin: 20px 0; }
              .stat-item { text-align: center; background: white; padding: 15px; border-radius: 6px; flex: 1; margin: 0 5px; }
              .stat-number { font-size: 24px; font-weight: bold; color: #3B82F6; }
              .domain-list { background: white; padding: 15px; margin: 10px 0; border-radius: 6px; }
              .expiring { color: #EF4444; }
              .expired { color: #DC2626; background: #FEE2E2; padding: 2px 6px; border-radius: 4px; }
            </style>
          </head>
          <body>
            <div class="email-container">
              <div class="header">
                <h1>DomMate ÂüüÂêçÁõëÊéßÊó•Êä•</h1>
                <p>{{date}}</p>
              </div>
              <div class="content">
                <div class="stats">
                  <div class="stat-item">
                    <div class="stat-number">{{totalDomains}}</div>
                    <div>ÊÄªÂüüÂêçÊï∞</div>
                  </div>
                  <div class="stat-item">
                    <div class="stat-number expiring">{{expiringDomains}}</div>
                    <div>Âç≥Â∞ÜÂà∞Êúü</div>
                  </div>
                  <div class="stat-item">
                    <div class="stat-number" style="color: #EF4444;">{{expiredDomains}}</div>
                    <div>Â∑≤ËøáÊúü</div>
                  </div>
                </div>
                {{#if expiringSoon}}
                <div class="domain-list">
                  <h3>ËøëÊúüÂà∞ÊúüÂüüÂêç</h3>
                  {{#each expiringSoon}}
                  <p>‚Ä¢ {{domain}} - Ââ©‰Ωô {{days}} Â§©</p>
                  {{/each}}
                </div>
                {{/if}}
                {{#if expiredDomains}}
                <div class="domain-list">
                  <h3>Â∑≤ËøáÊúüÂüüÂêç</h3>
                  {{#each expiredList}}
                  <p class="expired">‚Ä¢ {{domain}} - Â∑≤ËøáÊúü {{days}} Â§©</p>
                  {{/each}}
                </div>
                {{/if}}
              </div>
            </div>
          </body>
          </html>
        `,
        textContent: 'DomMate ÂüüÂêçÁõëÊéßÊó•Êä• - {{date}}\n\nÁªüËÆ°‰ø°ÊÅØÔºö\n- ÊÄªÂüüÂêçÊï∞: {{totalDomains}}\n- Âç≥Â∞ÜÂà∞Êúü: {{expiringDomains}}\n- Â∑≤ËøáÊúü: {{expiredDomains}}\n\n{{#if expiringSoon}}ËøëÊúüÂà∞ÊúüÂüüÂêçÔºö\n{{#each expiringSoon}}‚Ä¢ {{domain}} - Ââ©‰Ωô {{days}} Â§©\n{{/each}}{{/if}}',
        variables: JSON.stringify(['date', 'totalDomains', 'expiringDomains', 'expiredDomains', 'expiringSoon', 'expiredList']),
        isDefault: true,
        isActive: true
      }
    ];

    for (const template of defaultTemplates) {
      await this.addEmailTemplateIfNotExists(template);
    }
  }

  // Ê∑ªÂä†ÈÇÆ‰ª∂Ê®°ÊùøÔºàÂ¶ÇÊûú‰∏çÂ≠òÂú®Ôºâ
  async addEmailTemplateIfNotExists(templateData) {
    const {
      id, name, type, language, subject, htmlContent, textContent,
      variables, isDefault, isActive
    } = templateData;
    const now = new Date().toISOString();

    const insertSQL = `
      INSERT OR IGNORE INTO email_templates (
        id, name, type, language, subject, htmlContent, textContent,
        variables, isDefault, isActive, createdAt, updatedAt
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `;

    return new Promise((resolve, reject) => {
      this.db.run(insertSQL, [
        id, name, type, language, subject, htmlContent, textContent,
        variables, isDefault ? 1 : 0, isActive ? 1 : 0, now, now
      ], function(err) {
        if (err) {
          console.error('ÂàõÂª∫ÈªòËÆ§ÈÇÆ‰ª∂Ê®°ÊùøÂ§±Ë¥•:', err.message);
          reject(err);
        } else {
          if (this.changes > 0) {
            console.log(`‚úÖ ÈªòËÆ§ÈÇÆ‰ª∂Ê®°Êùø"${name}"ÂàõÂª∫ÊàêÂäü`);
          }
          resolve();
        }
      });
    });
  }

  // Ê∑ªÂä†ÂüüÂêç
  async addDomain(domainData) {
    const {
      id,
      domain,
      registrar,
      expiresAt,
      dnsProvider,
      domainStatus,
      status,
      lastCheck,
      isImportant,
      notes,
      createdAt,
      updatedAt
    } = domainData;

    const insertSQL = `
      INSERT INTO domains (
        id, domain, registrar, expiresAt, dnsProvider, domainStatus, 
        status, lastCheck, isImportant, notes, createdAt, updatedAt
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `;

    return new Promise((resolve, reject) => {
      this.db.run(insertSQL, [
        id, domain, registrar, expiresAt, dnsProvider, domainStatus,
        status, lastCheck, isImportant ? 1 : 0, notes || null, createdAt, updatedAt
      ], function(err) {
        if (err) {
          console.error('Ê∑ªÂä†ÂüüÂêçÂ§±Ë¥•:', err.message);
          reject(err);
        } else {
          console.log(`‚úÖ ÂüüÂêç ${domain} Ê∑ªÂä†ÊàêÂäü`);
          resolve({ ...domainData, rowId: this.lastID });
        }
      });
    });
  }

  // Ëé∑ÂèñÊâÄÊúâÂüüÂêç
  async getAllDomains() {
    const selectSQL = `SELECT * FROM domains ORDER BY createdAt DESC`;

    return new Promise((resolve, reject) => {
      this.db.all(selectSQL, [], (err, rows) => {
        if (err) {
          console.error('Ëé∑ÂèñÂüüÂêçÂàóË°®Â§±Ë¥•:', err.message);
          reject(err);
        } else {
          // ËΩ¨Êç¢Êï∞ÊçÆÁ±ªÂûã
          const domains = rows.map(row => ({
            ...row,
            isImportant: Boolean(row.isImportant),
            notes: row.notes || null,
            expiresAt: row.expiresAt || null,
            lastCheck: row.lastCheck || null
          }));
          resolve(domains);
        }
      });
    });
  }

  // Ê†πÊçÆIDËé∑ÂèñÂüüÂêç
  async getDomainById(id) {
    const selectSQL = `SELECT * FROM domains WHERE id = ?`;

    return new Promise((resolve, reject) => {
      this.db.get(selectSQL, [id], (err, row) => {
        if (err) {
          reject(err);
        } else if (row) {
          resolve({
            ...row,
            isImportant: Boolean(row.isImportant),
            notes: row.notes || null
          });
        } else {
          resolve(null);
        }
      });
    });
  }

  // Ê†πÊçÆÂüüÂêçËé∑ÂèñËÆ∞ÂΩï
  async getDomainByName(domain) {
    const selectSQL = `SELECT * FROM domains WHERE domain = ?`;

    return new Promise((resolve, reject) => {
      this.db.get(selectSQL, [domain], (err, row) => {
        if (err) {
          reject(err);
        } else if (row) {
          resolve({
            ...row,
            isImportant: Boolean(row.isImportant),
            notes: row.notes || null
          });
        } else {
          resolve(null);
        }
      });
    });
  }

  // Êõ¥Êñ∞ÂüüÂêç‰ø°ÊÅØ
  async updateDomain(id, updateData) {
    const fields = [];
    const values = [];

    // Âä®ÊÄÅÊûÑÂª∫Êõ¥Êñ∞Â≠óÊÆµ
    for (const [key, value] of Object.entries(updateData)) {
      if (key !== 'id') {
        fields.push(`${key} = ?`);
        if (key === 'isImportant') {
          values.push(value ? 1 : 0);
        } else {
          values.push(value);
        }
      }
    }

    // Ê∑ªÂä†updatedAt
    fields.push('updatedAt = ?');
    values.push(new Date().toISOString());
    values.push(id);

    const updateSQL = `UPDATE domains SET ${fields.join(', ')} WHERE id = ?`;

    return new Promise((resolve, reject) => {
      this.db.run(updateSQL, values, function(err) {
        if (err) {
          console.error('Êõ¥Êñ∞ÂüüÂêçÂ§±Ë¥•:', err.message);
          reject(err);
        } else {
          console.log(`‚úÖ ÂüüÂêç ${id} Êõ¥Êñ∞ÊàêÂäü`);
          resolve({ changes: this.changes });
        }
      });
    });
  }

  // Âà†Èô§ÂüüÂêç
  async deleteDomain(id) {
    const deleteSQL = `DELETE FROM domains WHERE id = ?`;

    return new Promise((resolve, reject) => {
      this.db.run(deleteSQL, [id], function(err) {
        if (err) {
          console.error('Âà†Èô§ÂüüÂêçÂ§±Ë¥•:', err.message);
          reject(err);
        } else {
          console.log(`‚úÖ ÂüüÂêç ${id} Âà†Èô§ÊàêÂäü`);
          resolve({ changes: this.changes });
        }
      });
    });
  }

  // Ëé∑ÂèñÂüüÂêçÁªüËÆ°‰ø°ÊÅØ
  async getDomainStats() {
    const statsSQL = `
      SELECT 
        status,
        COUNT(*) as count
      FROM domains 
      GROUP BY status
    `;

    return new Promise((resolve, reject) => {
      this.db.all(statsSQL, [], (err, rows) => {
        if (err) {
          reject(err);
        } else {
          const stats = {
            total: 0,
            normal: 0,
            expiring: 0,
            expired: 0,
            failed: 0,
            unregistered: 0
          };

          rows.forEach(row => {
            stats[row.status] = row.count;
            stats.total += row.count;
          });

          resolve(stats);
        }
      });
    });
  }

  // ====== ÂàÜÁªÑÁÆ°ÁêÜÁõ∏ÂÖ≥ÊñπÊ≥ï ======

  // Ëé∑ÂèñÊâÄÊúâÂàÜÁªÑ
  async getAllGroups() {
    const selectSQL = `
      SELECT g.*, 
             COUNT(dg.domainId) as domainCount
      FROM groups g
      LEFT JOIN domain_groups dg ON g.id = dg.groupId
      GROUP BY g.id, g.name, g.description, g.color, g.createdAt, g.updatedAt
      ORDER BY g.createdAt ASC
    `;

    return new Promise((resolve, reject) => {
      this.db.all(selectSQL, [], (err, rows) => {
        if (err) {
          reject(err);
        } else {
          resolve(rows);
        }
      });
    });
  }

  // ÂàõÂª∫Êñ∞ÂàÜÁªÑ
  async createGroup(groupData) {
    const { name, description, color } = groupData;
    const id = 'group_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    const now = new Date().toISOString();

    const insertSQL = `
      INSERT INTO groups (id, name, description, color, createdAt, updatedAt)
      VALUES (?, ?, ?, ?, ?, ?)
    `;

    return new Promise((resolve, reject) => {
      this.db.run(insertSQL, [id, name, description, color, now, now], function(err) {
        if (err) {
          reject(err);
        } else {
          resolve({
            id,
            name,
            description,
            color,
            createdAt: now,
            updatedAt: now,
            domainCount: 0
          });
        }
      });
    });
  }

  // Êõ¥Êñ∞ÂàÜÁªÑ
  async updateGroup(id, groupData) {
    const { name, description, color } = groupData;
    const updatedAt = new Date().toISOString();

    const updateSQL = `
      UPDATE groups 
      SET name = ?, description = ?, color = ?, updatedAt = ?
      WHERE id = ?
    `;

    return new Promise((resolve, reject) => {
      this.db.run(updateSQL, [name, description, color, updatedAt, id], function(err) {
        if (err) {
          reject(err);
        } else if (this.changes === 0) {
          reject(new Error('ÂàÜÁªÑ‰∏çÂ≠òÂú®'));
        } else {
          resolve({ id, name, description, color, updatedAt });
        }
      });
    });
  }

  // Âà†Èô§ÂàÜÁªÑ
  async deleteGroup(id) {
    // Ê£ÄÊü•ÊòØÂê¶‰∏∫ÈªòËÆ§ÂàÜÁªÑ
    if (['default', 'important', 'development'].includes(id)) {
      throw new Error('Êó†Ê≥ïÂà†Èô§Á≥ªÁªüÈªòËÆ§ÂàÜÁªÑ');
    }

    const deleteSQL = `DELETE FROM groups WHERE id = ?`;

    return new Promise((resolve, reject) => {
      this.db.run(deleteSQL, [id], function(err) {
        if (err) {
          reject(err);
        } else if (this.changes === 0) {
          reject(new Error('ÂàÜÁªÑ‰∏çÂ≠òÂú®'));
        } else {
          resolve({ success: true, deletedCount: this.changes });
        }
      });
    });
  }

  // Â∞ÜÂüüÂêçÊ∑ªÂä†Âà∞ÂàÜÁªÑ
  async addDomainToGroup(domainId, groupId) {
    const id = 'dg_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
    const createdAt = new Date().toISOString();

    const insertSQL = `
      INSERT OR IGNORE INTO domain_groups (id, domainId, groupId, createdAt)
      VALUES (?, ?, ?, ?)
    `;

    return new Promise((resolve, reject) => {
      this.db.run(insertSQL, [id, domainId, groupId, createdAt], function(err) {
        if (err) {
          reject(err);
        } else {
          resolve({ success: true, added: this.changes > 0 });
        }
      });
    });
  }

  // ‰ªéÂàÜÁªÑ‰∏≠ÁßªÈô§ÂüüÂêç
  async removeDomainFromGroup(domainId, groupId) {
    const deleteSQL = `
      DELETE FROM domain_groups 
      WHERE domainId = ? AND groupId = ?
    `;

    return new Promise((resolve, reject) => {
      this.db.run(deleteSQL, [domainId, groupId], function(err) {
        if (err) {
          reject(err);
        } else {
          resolve({ success: true, removed: this.changes > 0 });
        }
      });
    });
  }

  // Ëé∑ÂèñÂàÜÁªÑ‰∏≠ÁöÑÂüüÂêç
  async getDomainsByGroup(groupId) {
    const selectSQL = `
      SELECT d.*
      FROM domains d
      INNER JOIN domain_groups dg ON d.id = dg.domainId
      WHERE dg.groupId = ?
      ORDER BY d.domain ASC
    `;

    return new Promise((resolve, reject) => {
      this.db.all(selectSQL, [groupId], (err, rows) => {
        if (err) {
          reject(err);
        } else {
          resolve(rows);
        }
      });
    });
  }

  // Ëé∑ÂèñÊú™ÂàÜÁªÑÁöÑÂüüÂêç
  async getUngroupedDomains() {
    const selectSQL = `
      SELECT d.*
      FROM domains d
      LEFT JOIN domain_groups dg ON d.id = dg.domainId
      WHERE dg.domainId IS NULL
      ORDER BY d.domain ASC
    `;

    return new Promise((resolve, reject) => {
      this.db.all(selectSQL, [], (err, rows) => {
        if (err) {
          reject(err);
        } else {
          resolve(rows);
        }
      });
    });
  }

  // Ëé∑ÂèñÂüüÂêçÁöÑÂàÜÁªÑ‰ø°ÊÅØ
  async getDomainGroups(domainId) {
    const selectSQL = `
      SELECT g.*
      FROM groups g
      INNER JOIN domain_groups dg ON g.id = dg.groupId
      WHERE dg.domainId = ?
      ORDER BY g.name ASC
    `;

    return new Promise((resolve, reject) => {
      this.db.all(selectSQL, [domainId], (err, rows) => {
        if (err) {
          reject(err);
        } else {
          resolve(rows);
        }
      });
    });
  }

  // Ëé∑ÂèñÂàÜÁªÑÁªüËÆ°‰ø°ÊÅØ
  async getGroupStats() {
    const statsSQL = `
      SELECT 
        g.id,
        g.name,
        g.color,
        COUNT(dg.domainId) as domainCount,
        COUNT(CASE WHEN d.status = 'normal' THEN 1 END) as normalCount,
        COUNT(CASE WHEN d.status = 'expiring' THEN 1 END) as expiringCount,
        COUNT(CASE WHEN d.status = 'expired' THEN 1 END) as expiredCount,
        COUNT(CASE WHEN d.status = 'failed' THEN 1 END) as failedCount
      FROM groups g
      LEFT JOIN domain_groups dg ON g.id = dg.groupId
      LEFT JOIN domains d ON dg.domainId = d.id
      GROUP BY g.id, g.name, g.color
      ORDER BY g.name ASC
    `;

    return new Promise((resolve, reject) => {
      this.db.all(statsSQL, [], (err, rows) => {
        if (err) {
          reject(err);
        } else {
          resolve(rows);
        }
      });
    });
  }

  // Ëé∑ÂèñÂç≥Â∞ÜÂà∞ÊúüÁöÑÂüüÂêç (90Â§©ÂÜÖ)
  async getExpiringDomains(days = 90) {
    const thresholdDate = new Date();
    thresholdDate.setDate(thresholdDate.getDate() + days);
    
    const selectSQL = `
      SELECT * FROM domains 
      WHERE expiresAt IS NOT NULL 
      AND datetime(expiresAt) <= datetime(?)
      AND status = 'normal'
      ORDER BY expiresAt ASC
    `;

    return new Promise((resolve, reject) => {
      this.db.all(selectSQL, [thresholdDate.toISOString()], (err, rows) => {
        if (err) {
          reject(err);
        } else {
          const domains = rows.map(row => ({
            ...row,
            isImportant: Boolean(row.isImportant),
            notes: row.notes || null
          }));
          resolve(domains);
        }
      });
    });
  }

  // ÊâπÈáèÊõ¥Êñ∞ÂüüÂêçÁä∂ÊÄÅ
  async updateDomainStatuses() {
    const now = new Date();
    const expiring90Days = new Date(now.getTime() + (90 * 24 * 60 * 60 * 1000));

    // Êõ¥Êñ∞Â∑≤ËøáÊúüÁöÑÂüüÂêç
    const updateExpiredSQL = `
      UPDATE domains 
      SET status = 'expired', updatedAt = ?
      WHERE datetime(expiresAt) <= datetime(?) 
      AND status NOT IN ('failed', 'unregistered')
    `;

    // Êõ¥Êñ∞Âç≥Â∞ÜÂà∞ÊúüÁöÑÂüüÂêç (90Â§©ÂÜÖ)
    const updateExpiringSQL = `
      UPDATE domains 
      SET status = 'expiring', updatedAt = ?
      WHERE datetime(expiresAt) > datetime(?) 
      AND datetime(expiresAt) <= datetime(?) 
      AND status NOT IN ('failed', 'unregistered', 'expired')
    `;

    const currentTime = now.toISOString();

    return new Promise((resolve, reject) => {
      this.db.serialize(() => {
        this.db.run(updateExpiredSQL, [currentTime, currentTime], (err) => {
          if (err) {
            console.error('Êõ¥Êñ∞ËøáÊúüÂüüÂêçÁä∂ÊÄÅÂ§±Ë¥•:', err);
            reject(err);
            return;
          }
        });

        this.db.run(updateExpiringSQL, [currentTime, currentTime, expiring90Days.toISOString()], function(err) {
          if (err) {
            console.error('Êõ¥Êñ∞Âç≥Â∞ÜÂà∞ÊúüÂüüÂêçÁä∂ÊÄÅÂ§±Ë¥•:', err);
            reject(err);
          } else {
            console.log('‚úÖ ÂüüÂêçÁä∂ÊÄÅÊâπÈáèÊõ¥Êñ∞ÂÆåÊàê');
            resolve();
          }
        });
      });
    });
  }

  // ÂÖ≥Èó≠Êï∞ÊçÆÂ∫ìËøûÊé•
  close() {
    return new Promise((resolve) => {
      if (this.db) {
        this.db.close((err) => {
          if (err) {
            console.error('ÂÖ≥Èó≠Êï∞ÊçÆÂ∫ìËøûÊé•Â§±Ë¥•:', err.message);
          } else {
            console.log('‚úÖ Êï∞ÊçÆÂ∫ìËøûÊé•Â∑≤ÂÖ≥Èó≠');
          }
          resolve();
        });
      } else {
        resolve();
      }
    });
  }

  // ===============================
  // ÈÇÆ‰ª∂ÈÖçÁΩÆÁõ∏ÂÖ≥Êìç‰Ωú
  // ===============================

  // Ëé∑ÂèñÊâÄÊúâÈÇÆ‰ª∂ÈÖçÁΩÆ
  async getAllEmailConfigs() {
    const sql = `SELECT * FROM email_configs ORDER BY isDefault DESC, createdAt ASC`;
    
    return new Promise((resolve, reject) => {
      this.db.all(sql, [], (err, rows) => {
        if (err) {
          reject(err);
        } else {
          // Â∞ÜbooleanÂ≠óÊÆµËΩ¨Êç¢‰∏∫ÁúüÊ≠£ÁöÑbooleanÂÄº
          const configs = rows.map(row => ({
            ...row,
            secure: Boolean(row.secure),
            isDefault: Boolean(row.isDefault),
            isActive: Boolean(row.isActive)
          }));
          resolve(configs);
        }
      });
    });
  }

  // Ê†πÊçÆIDËé∑ÂèñÈÇÆ‰ª∂ÈÖçÁΩÆ
  async getEmailConfigById(id) {
    const sql = `SELECT * FROM email_configs WHERE id = ?`;
    
    return new Promise((resolve, reject) => {
      this.db.get(sql, [id], (err, row) => {
        if (err) {
          reject(err);
        } else if (!row) {
          resolve(null);
        } else {
          resolve({
            ...row,
            secure: Boolean(row.secure),
            isDefault: Boolean(row.isDefault),
            isActive: Boolean(row.isActive)
          });
        }
      });
    });
  }

  // Ê∑ªÂä†ÈÇÆ‰ª∂ÈÖçÁΩÆ
  async addEmailConfig(configData) {
    const {
      id, name, host, port, secure, username, password,
      fromEmail, fromName, isDefault, isActive
    } = configData;
    const now = new Date().toISOString();

    // Â¶ÇÊûúËÆæÁΩÆ‰∏∫ÈªòËÆ§ÈÖçÁΩÆÔºåÂÖàÂèñÊ∂àÂÖ∂‰ªñÈÖçÁΩÆÁöÑÈªòËÆ§Áä∂ÊÄÅ
    if (isDefault) {
      await this.unsetDefaultEmailConfig();
    }

    const insertSQL = `
      INSERT INTO email_configs (
        id, name, host, port, secure, username, password,
        fromEmail, fromName, isDefault, isActive, createdAt, updatedAt
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `;

    return new Promise((resolve, reject) => {
      this.db.run(insertSQL, [
        id, name, host, port, secure ? 1 : 0, username, password,
        fromEmail, fromName, isDefault ? 1 : 0, isActive ? 1 : 0, now, now
      ], function(err) {
        if (err) {
          reject(err);
        } else {
          resolve({ ...configData, createdAt: now, updatedAt: now });
        }
      });
    });
  }

  // Êõ¥Êñ∞ÈÇÆ‰ª∂ÈÖçÁΩÆ
  async updateEmailConfig(id, updateData) {
    const { isDefault } = updateData;
    const now = new Date().toISOString();

    // Â¶ÇÊûúËÆæÁΩÆ‰∏∫ÈªòËÆ§ÈÖçÁΩÆÔºåÂÖàÂèñÊ∂àÂÖ∂‰ªñÈÖçÁΩÆÁöÑÈªòËÆ§Áä∂ÊÄÅ
    if (isDefault) {
      await this.unsetDefaultEmailConfig();
    }

    const setClause = [];
    const params = [];

    Object.keys(updateData).forEach(key => {
      if (key !== 'id') {
        setClause.push(`${key} = ?`);
        if (key === 'secure' || key === 'isDefault' || key === 'isActive') {
          params.push(updateData[key] ? 1 : 0);
        } else {
          params.push(updateData[key]);
        }
      }
    });

    setClause.push('updatedAt = ?');
    params.push(now, id);

    const updateSQL = `UPDATE email_configs SET ${setClause.join(', ')} WHERE id = ?`;

    return new Promise((resolve, reject) => {
      this.db.run(updateSQL, params, function(err) {
        if (err) {
          reject(err);
        } else if (this.changes === 0) {
          reject(new Error('ÈÇÆ‰ª∂ÈÖçÁΩÆ‰∏çÂ≠òÂú®'));
        } else {
          resolve({ success: true });
        }
      });
    });
  }

  // Âà†Èô§ÈÇÆ‰ª∂ÈÖçÁΩÆ
  async deleteEmailConfig(id) {
    const deleteSQL = `DELETE FROM email_configs WHERE id = ?`;

    return new Promise((resolve, reject) => {
      this.db.run(deleteSQL, [id], function(err) {
        if (err) {
          reject(err);
        } else if (this.changes === 0) {
          reject(new Error('ÈÇÆ‰ª∂ÈÖçÁΩÆ‰∏çÂ≠òÂú®'));
        } else {
          resolve({ success: true, deletedCount: this.changes });
        }
      });
    });
  }

  // ÂèñÊ∂àÊâÄÊúâÈÖçÁΩÆÁöÑÈªòËÆ§Áä∂ÊÄÅ
  async unsetDefaultEmailConfig() {
    const updateSQL = `UPDATE email_configs SET isDefault = 0`;
    
    return new Promise((resolve, reject) => {
      this.db.run(updateSQL, [], (err) => {
        if (err) {
          reject(err);
        } else {
          resolve();
        }
      });
    });
  }

  // Ëé∑ÂèñÈªòËÆ§ÈÇÆ‰ª∂ÈÖçÁΩÆ
  async getDefaultEmailConfig() {
    const sql = `SELECT * FROM email_configs WHERE isDefault = 1 AND isActive = 1 LIMIT 1`;
    
    return new Promise((resolve, reject) => {
      this.db.get(sql, [], (err, row) => {
        if (err) {
          reject(err);
        } else if (!row) {
          resolve(null);
        } else {
          resolve({
            ...row,
            secure: Boolean(row.secure),
            isDefault: Boolean(row.isDefault),
            isActive: Boolean(row.isActive)
          });
        }
      });
    });
  }

  // ===============================
  // ÈÇÆ‰ª∂Ê®°ÊùøÁõ∏ÂÖ≥Êìç‰Ωú
  // ===============================

  // Ëé∑ÂèñÊâÄÊúâÈÇÆ‰ª∂Ê®°Êùø
  async getAllEmailTemplates() {
    const sql = `
      SELECT * FROM email_templates 
      ORDER BY isDefault DESC, type, language, createdAt ASC
    `;
    
    return new Promise((resolve, reject) => {
      this.db.all(sql, [], (err, rows) => {
        if (err) {
          reject(err);
        } else {
          const templates = rows.map(row => ({
            ...row,
            isDefault: Boolean(row.isDefault),
            isActive: Boolean(row.isActive),
            variables: row.variables ? JSON.parse(row.variables) : []
          }));
          resolve(templates);
        }
      });
    });
  }

  // Ê†πÊçÆÁ±ªÂûãÂíåËØ≠Ë®ÄËé∑ÂèñÈÇÆ‰ª∂Ê®°Êùø
  async getEmailTemplatesByTypeAndLanguage(type, language) {
    const sql = `
      SELECT * FROM email_templates 
      WHERE type = ? AND language = ? AND isActive = 1
      ORDER BY isDefault DESC, createdAt ASC
    `;
    
    return new Promise((resolve, reject) => {
      this.db.all(sql, [type, language], (err, rows) => {
        if (err) {
          reject(err);
        } else {
          const templates = rows.map(row => ({
            ...row,
            isDefault: Boolean(row.isDefault),
            isActive: Boolean(row.isActive),
            variables: row.variables ? JSON.parse(row.variables) : []
          }));
          resolve(templates);
        }
      });
    });
  }

  // Ê†πÊçÆIDËé∑ÂèñÈÇÆ‰ª∂Ê®°Êùø
  async getEmailTemplateById(id) {
    const sql = `SELECT * FROM email_templates WHERE id = ?`;
    
    return new Promise((resolve, reject) => {
      this.db.get(sql, [id], (err, row) => {
        if (err) {
          reject(err);
        } else if (!row) {
          resolve(null);
        } else {
          resolve({
            ...row,
            isDefault: Boolean(row.isDefault),
            isActive: Boolean(row.isActive),
            variables: row.variables ? JSON.parse(row.variables) : []
          });
        }
      });
    });
  }

  // Ê∑ªÂä†ÈÇÆ‰ª∂Ê®°Êùø
  async addEmailTemplate(templateData) {
    const {
      id, name, type, language, subject, htmlContent, textContent,
      variables, isDefault, isActive
    } = templateData;
    const now = new Date().toISOString();

    const insertSQL = `
      INSERT INTO email_templates (
        id, name, type, language, subject, htmlContent, textContent,
        variables, isDefault, isActive, createdAt, updatedAt
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `;

    return new Promise((resolve, reject) => {
      this.db.run(insertSQL, [
        id, name, type, language, subject, htmlContent, textContent,
        JSON.stringify(variables || []), isDefault ? 1 : 0, isActive ? 1 : 0, now, now
      ], function(err) {
        if (err) {
          reject(err);
        } else {
          resolve({ ...templateData, createdAt: now, updatedAt: now });
        }
      });
    });
  }

  // Êõ¥Êñ∞ÈÇÆ‰ª∂Ê®°Êùø
  async updateEmailTemplate(id, updateData) {
    const now = new Date().toISOString();

    const setClause = [];
    const params = [];

    Object.keys(updateData).forEach(key => {
      if (key !== 'id') {
        setClause.push(`${key} = ?`);
        if (key === 'variables') {
          params.push(JSON.stringify(updateData[key] || []));
        } else if (key === 'isDefault' || key === 'isActive') {
          params.push(updateData[key] ? 1 : 0);
        } else {
          params.push(updateData[key]);
        }
      }
    });

    setClause.push('updatedAt = ?');
    params.push(now, id);

    const updateSQL = `UPDATE email_templates SET ${setClause.join(', ')} WHERE id = ?`;

    return new Promise((resolve, reject) => {
      this.db.run(updateSQL, params, function(err) {
        if (err) {
          reject(err);
        } else if (this.changes === 0) {
          reject(new Error('ÈÇÆ‰ª∂Ê®°Êùø‰∏çÂ≠òÂú®'));
        } else {
          resolve({ success: true });
        }
      });
    });
  }

  // Âà†Èô§ÈÇÆ‰ª∂Ê®°Êùø
  async deleteEmailTemplate(id) {
    const deleteSQL = `DELETE FROM email_templates WHERE id = ?`;

    return new Promise((resolve, reject) => {
      this.db.run(deleteSQL, [id], function(err) {
        if (err) {
          reject(err);
        } else if (this.changes === 0) {
          reject(new Error('ÈÇÆ‰ª∂Ê®°Êùø‰∏çÂ≠òÂú®'));
        } else {
          resolve({ success: true, deletedCount: this.changes });
        }
      });
    });
  }

  // ===============================
  // ÈÄöÁü•ËßÑÂàôÁõ∏ÂÖ≥Êìç‰Ωú
  // ===============================

  // Ëé∑ÂèñÊâÄÊúâÈÄöÁü•ËßÑÂàô
  async getAllNotificationRules() {
    const sql = `
      SELECT nr.*, ec.name as emailConfigName, et.name as templateName
      FROM notification_rules nr
      LEFT JOIN email_configs ec ON nr.emailConfigId = ec.id
      LEFT JOIN email_templates et ON nr.templateId = et.id
      ORDER BY nr.isActive DESC, nr.createdAt ASC
    `;
    
    return new Promise((resolve, reject) => {
      this.db.all(sql, [], (err, rows) => {
        if (err) {
          reject(err);
        } else {
          const rules = rows.map(row => ({
            ...row,
            isActive: Boolean(row.isActive),
            recipients: row.recipients ? JSON.parse(row.recipients) : []
          }));
          resolve(rules);
        }
      });
    });
  }

  // Ê†πÊçÆIDËé∑ÂèñÈÄöÁü•ËßÑÂàô
  async getNotificationRuleById(id) {
    const sql = `
      SELECT nr.*, ec.name as emailConfigName, et.name as templateName
      FROM notification_rules nr
      LEFT JOIN email_configs ec ON nr.emailConfigId = ec.id
      LEFT JOIN email_templates et ON nr.templateId = et.id
      WHERE nr.id = ?
    `;
    
    return new Promise((resolve, reject) => {
      this.db.get(sql, [id], (err, row) => {
        if (err) {
          reject(err);
        } else if (!row) {
          resolve(null);
        } else {
          resolve({
            ...row,
            isActive: Boolean(row.isActive),
            recipients: row.recipients ? JSON.parse(row.recipients) : []
          });
        }
      });
    });
  }

  // Ê∑ªÂä†ÈÄöÁü•ËßÑÂàô
  async addNotificationRule(ruleData) {
    const {
      id, name, type, days, scheduleHour, scheduleMinute, scheduleWeekday,
      isActive, emailConfigId, templateId, recipients
    } = ruleData;
    const now = new Date().toISOString();

    // ÁîüÊàêcronË°®ËææÂºè
    const cronExpression = this.generateCronExpression(type, scheduleHour, scheduleMinute, scheduleWeekday);

    const insertSQL = `
      INSERT INTO notification_rules (
        id, name, type, days, scheduleHour, scheduleMinute, scheduleWeekday,
        cronExpression, isActive, emailConfigId, templateId,
        recipients, runCount, createdAt, updatedAt
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, 0, ?, ?)
    `;

    return new Promise((resolve, reject) => {
      this.db.run(insertSQL, [
        id, name, type, days || null, scheduleHour || 8, scheduleMinute || 0, 
        scheduleWeekday || null, cronExpression, isActive ? 1 : 0, 
        emailConfigId, templateId, JSON.stringify(recipients || []), now, now
      ], function(err) {
        if (err) {
          reject(err);
        } else {
          resolve({ 
            ...ruleData, 
            cronExpression,
            runCount: 0, 
            createdAt: now, 
            updatedAt: now 
          });
        }
      });
    });
  }

  // Êõ¥Êñ∞ÈÄöÁü•ËßÑÂàô
  async updateNotificationRule(id, updates) {
    // ÁîüÊàêÊñ∞ÁöÑcronË°®ËææÂºè
    let cronExpression = null;
    if (updates.type || updates.scheduleHour !== undefined || 
        updates.scheduleMinute !== undefined || updates.scheduleWeekday !== undefined) {
      
      // ÂÖàËé∑ÂèñÂΩìÂâçËßÑÂàô
      return new Promise((resolve, reject) => {
        this.db.get(
          'SELECT * FROM notification_rules WHERE id = ?', 
          [id], 
          (err, currentRule) => {
            if (err) {
              reject(err);
              return;
            }
            if (!currentRule) {
              reject(new Error('ÈÄöÁü•ËßÑÂàô‰∏çÂ≠òÂú®'));
              return;
            }

            // ÂêàÂπ∂Êõ¥Êñ∞Êï∞ÊçÆ
            const mergedData = {
              type: updates.type || currentRule.type,
              scheduleHour: updates.scheduleHour !== undefined ? updates.scheduleHour : currentRule.scheduleHour,
              scheduleMinute: updates.scheduleMinute !== undefined ? updates.scheduleMinute : currentRule.scheduleMinute,
              scheduleWeekday: updates.scheduleWeekday !== undefined ? updates.scheduleWeekday : currentRule.scheduleWeekday
            };

            // ÁîüÊàêÊñ∞ÁöÑcronË°®ËææÂºè
            cronExpression = this.generateCronExpression(
              mergedData.type,
              mergedData.scheduleHour,
              mergedData.scheduleMinute,
              mergedData.scheduleWeekday
            );

            // ÊâßË°åÊõ¥Êñ∞
            this.performUpdate(id, updates, cronExpression, resolve, reject);
          }
        );
      });
    } else {
      // Áõ¥Êé•Êõ¥Êñ∞Ôºå‰∏çÈúÄË¶ÅÈáçÊñ∞ÁîüÊàêcronË°®ËææÂºè
      return new Promise((resolve, reject) => {
        this.performUpdate(id, updates, null, resolve, reject);
      });
    }
  }

  // ÊâßË°åÊõ¥Êñ∞Êìç‰Ωú
  performUpdate(id, updates, cronExpression, resolve, reject) {
    const fields = [];
    const values = [];

    // ÊûÑÂª∫Êõ¥Êñ∞Â≠óÊÆµ
    const updateableFields = [
      'name', 'type', 'days', 'scheduleHour', 'scheduleMinute', 
      'scheduleWeekday', 'isActive', 'emailConfigId', 'templateId', 'recipients'
    ];

    updateableFields.forEach(field => {
      if (updates[field] !== undefined) {
        fields.push(`${field} = ?`);
        if (field === 'recipients') {
          values.push(JSON.stringify(updates[field]));
        } else if (field === 'isActive') {
          values.push(updates[field] ? 1 : 0);
        } else {
          values.push(updates[field]);
        }
      }
    });

    // Â¶ÇÊûúÊúâÊñ∞ÁöÑcronË°®ËææÂºèÔºå‰πüË¶ÅÊõ¥Êñ∞
    if (cronExpression) {
      fields.push('cronExpression = ?');
      values.push(cronExpression);
    }

    // Êõ¥Êñ∞Êó∂Èó¥
    fields.push('updatedAt = ?');
    values.push(new Date().toISOString());

    if (fields.length === 1) { // Âè™ÊúâupdatedAt
      resolve();
      return;
    }

    const updateSQL = `UPDATE notification_rules SET ${fields.join(', ')} WHERE id = ?`;
    values.push(id);

    this.db.run(updateSQL, values, function(err) {
      if (err) {
        console.error('Êõ¥Êñ∞ÈÄöÁü•ËßÑÂàôÂ§±Ë¥•:', err);
        reject(err);
      } else {
        resolve();
      }
    });
  }

  // ÁîüÊàêcronË°®ËææÂºè
  generateCronExpression(type, hour = 8, minute = 0, weekday = 1) {
    // È™åËØÅÂèÇÊï∞ËåÉÂõ¥
    hour = Math.max(0, Math.min(23, hour));
    minute = Math.max(0, Math.min(59, minute));
    weekday = Math.max(0, Math.min(6, weekday));

    switch (type) {
      case 'daily_summary':
        // ÊØèÊó•Âú®ÊåáÂÆöÊó∂Èó¥ÂèëÈÄÅ
        return `${minute} ${hour} * * *`;
      
      case 'weekly_summary':
        // ÊØèÂë®Âú®ÊåáÂÆöÊòüÊúüÁöÑÊåáÂÆöÊó∂Èó¥ÂèëÈÄÅ
        return `${minute} ${hour} * * ${weekday}`;
      
      case 'expiry_reminder':
        // Âà∞ÊúüÊèêÈÜíÊØèÂ§©Âú®ÊåáÂÆöÊó∂Èó¥Ê£ÄÊü•
        return `${minute} ${hour} * * *`;
      
      default:
        // ÈªòËÆ§ÊØèÂ§©8ÁÇπ
        return `0 8 * * *`;
    }
  }

  // Âà†Èô§ÈÄöÁü•ËßÑÂàô
  async deleteNotificationRule(id) {
    const deleteSQL = `DELETE FROM notification_rules WHERE id = ?`;

    return new Promise((resolve, reject) => {
      this.db.run(deleteSQL, [id], function(err) {
        if (err) {
          reject(err);
        } else if (this.changes === 0) {
          reject(new Error('ÈÄöÁü•ËßÑÂàô‰∏çÂ≠òÂú®'));
        } else {
          resolve({ success: true, deletedCount: this.changes });
        }
      });
    });
  }

  // Ëé∑ÂèñÊ¥ªË∑ÉÁöÑÈÄöÁü•ËßÑÂàô
  async getActiveNotificationRules() {
    const sql = `
      SELECT nr.*, ec.name as emailConfigName, et.name as templateName
      FROM notification_rules nr
      LEFT JOIN email_configs ec ON nr.emailConfigId = ec.id
      LEFT JOIN email_templates et ON nr.templateId = et.id
      WHERE nr.isActive = 1
      ORDER BY nr.type, nr.days
    `;
    
    return new Promise((resolve, reject) => {
      this.db.all(sql, [], (err, rows) => {
        if (err) {
          reject(err);
        } else {
          const rules = rows.map(row => ({
            ...row,
            isActive: Boolean(row.isActive),
            recipients: row.recipients ? JSON.parse(row.recipients) : []
          }));
          resolve(rules);
        }
      });
    });
  }

  // Êõ¥Êñ∞ÈÄöÁü•ËßÑÂàôÁöÑËøêË°å‰ø°ÊÅØ
  async updateNotificationRuleRunInfo(id, lastRun, nextRun) {
    const now = new Date().toISOString();
    const updateSQL = `
      UPDATE notification_rules 
      SET lastRun = ?, nextRun = ?, runCount = runCount + 1, updatedAt = ?
      WHERE id = ?
    `;

    return new Promise((resolve, reject) => {
      this.db.run(updateSQL, [lastRun, nextRun, now, id], function(err) {
        if (err) {
          reject(err);
        } else {
          resolve({ success: true });
        }
      });
    });
  }

  // ===============================
  // ÈÄöÁü•ËÆ∞ÂΩïÁõ∏ÂÖ≥Êìç‰Ωú
  // ===============================

  // Ëé∑ÂèñÈÄöÁü•ËÆ∞ÂΩï
  async getNotificationLogs(limit = 100, offset = 0) {
    const sql = `
      SELECT nl.*, nr.name as ruleName, nr.type as ruleType
      FROM notification_logs nl
      LEFT JOIN notification_rules nr ON nl.ruleId = nr.id
      ORDER BY nl.createdAt DESC
      LIMIT ? OFFSET ?
    `;
    
    return new Promise((resolve, reject) => {
      this.db.all(sql, [limit, offset], (err, rows) => {
        if (err) {
          reject(err);
        } else {
          const logs = rows.map(row => ({
            ...row,
            domainIds: row.domainIds ? JSON.parse(row.domainIds) : []
          }));
          resolve(logs);
        }
      });
    });
  }

  // Ê∑ªÂä†ÈÄöÁü•ËÆ∞ÂΩï
  async addNotificationLog(logData) {
    const {
      id, ruleId, domainIds, recipient, subject, status, errorMessage, sentAt, retryCount
    } = logData;
    const now = new Date().toISOString();

    const insertSQL = `
      INSERT INTO notification_logs (
        id, ruleId, domainIds, recipient, subject, status,
        errorMessage, sentAt, retryCount, createdAt
      ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
    `;

    return new Promise((resolve, reject) => {
      this.db.run(insertSQL, [
        id, ruleId, JSON.stringify(domainIds || []), recipient, subject,
        status, errorMessage, sentAt, retryCount || 0, now
      ], function(err) {
        if (err) {
          reject(err);
        } else {
          resolve({ ...logData, createdAt: now });
        }
      });
    });
  }

  // Êõ¥Êñ∞ÈÄöÁü•ËÆ∞ÂΩïÁä∂ÊÄÅ
  async updateNotificationLogStatus(id, status, errorMessage = null, sentAt = null) {
    const updateSQL = `
      UPDATE notification_logs 
      SET status = ?, errorMessage = ?, sentAt = ?, 
          retryCount = CASE WHEN status = 'retry' THEN retryCount + 1 ELSE retryCount END
      WHERE id = ?
    `;

    return new Promise((resolve, reject) => {
      this.db.run(updateSQL, [status, errorMessage, sentAt, id], function(err) {
        if (err) {
          reject(err);
        } else if (this.changes === 0) {
          reject(new Error('ÈÄöÁü•ËÆ∞ÂΩï‰∏çÂ≠òÂú®'));
        } else {
          resolve({ success: true });
        }
      });
    });
  }

  // Ëé∑ÂèñÂ§±Ë¥•ÁöÑÈÄöÁü•ËÆ∞ÂΩïÔºàÁî®‰∫éÈáçËØïÔºâ
  async getFailedNotificationLogs(retryLimit = 3) {
    const sql = `
      SELECT * FROM notification_logs 
      WHERE status IN ('failed', 'retry') AND retryCount < ?
      ORDER BY createdAt ASC
    `;
    
    return new Promise((resolve, reject) => {
      this.db.all(sql, [retryLimit], (err, rows) => {
        if (err) {
          reject(err);
        } else {
          const logs = rows.map(row => ({
            ...row,
            domainIds: row.domainIds ? JSON.parse(row.domainIds) : []
          }));
          resolve(logs);
        }
      });
    });
  }

  // Ëé∑ÂèñÂà∞ÊúüÊó∂Èó¥ÂàÜÂ∏ÉÊï∞ÊçÆ
  async getExpiryDistribution() {
    const sql = `
      SELECT 
        CASE 
          WHEN expiresAt IS NULL OR expiresAt = '' THEN 'Êú™Áü•'
          WHEN julianday(expiresAt) - julianday('now') < 0 THEN 'Â∑≤ËøáÊúü'
          WHEN julianday(expiresAt) - julianday('now') <= 30 THEN '30Â§©ÂÜÖ'
          WHEN julianday(expiresAt) - julianday('now') <= 90 THEN '31-90Â§©'
          WHEN julianday(expiresAt) - julianday('now') <= 180 THEN '91-180Â§©'
          WHEN julianday(expiresAt) - julianday('now') <= 365 THEN '181-365Â§©'
          ELSE '1Âπ¥‰ª•‰∏ä'
        END as period,
        COUNT(*) as count
      FROM domains 
      GROUP BY 1
      ORDER BY 
        CASE 
          WHEN period = 'Â∑≤ËøáÊúü' THEN 1
          WHEN period = '30Â§©ÂÜÖ' THEN 2
          WHEN period = '31-90Â§©' THEN 3
          WHEN period = '91-180Â§©' THEN 4
          WHEN period = '181-365Â§©' THEN 5
          WHEN period = '1Âπ¥‰ª•‰∏ä' THEN 6
          ELSE 7
        END
    `;

    return new Promise((resolve, reject) => {
      this.db.all(sql, [], (err, rows) => {
        if (err) {
          reject(err);
        } else {
          resolve(rows);
        }
      });
    });
  }

  // Ëé∑ÂèñÊ≥®ÂÜåÂïÜÁªüËÆ°Êï∞ÊçÆ
  async getRegistrarStats() {
    const sql = `
      SELECT 
        COALESCE(registrar, 'Êú™Áü•') as name,
        COUNT(*) as value,
        ROUND(COUNT(*) * 100.0 / (SELECT COUNT(*) FROM domains), 1) as percentage
      FROM domains 
      GROUP BY registrar
      ORDER BY value DESC
      LIMIT 10
    `;

    return new Promise((resolve, reject) => {
      this.db.all(sql, [], (err, rows) => {
        if (err) {
          reject(err);
        } else {
          // ‰∏∫ÊØè‰∏™Ê≥®ÂÜåÂïÜÂàÜÈÖçÈ¢úËâ≤
          const colors = [
            '#8884d8', '#82ca9d', '#ffc658', '#ff7300', '#8dd1e1',
            '#d084d0', '#82d982', '#ffb347', '#ff6b6b', '#4ecdc4'
          ];
          const result = rows.map((row, index) => ({
            ...row,
            fill: colors[index % colors.length]
          }));
          resolve(result);
        }
      });
    });
  }

  // Ëé∑ÂèñÊúàÂ∫¶Âà∞ÊúüË∂ãÂäø
  async getMonthlyExpiryTrend() {
    const sql = `
      SELECT 
        strftime('%Y-%m', expiresAt) as month,
        COUNT(*) as count
      FROM domains 
      WHERE expiresAt IS NOT NULL AND expiresAt != ''
        AND julianday(expiresAt) >= julianday('now', '-12 months')
        AND julianday(expiresAt) <= julianday('now', '+12 months')
      GROUP BY month
      ORDER BY month
    `;

    return new Promise((resolve, reject) => {
      this.db.all(sql, [], (err, rows) => {
        if (err) {
          reject(err);
        } else {
          // Ê†ºÂºèÂåñÊúà‰ªΩÊòæÁ§∫
          const result = rows.map(row => ({
            month: row.month,
            monthDisplay: this.formatMonth(row.month),
            count: row.count
          }));
          resolve(result);
        }
      });
    });
  }

  // Ëé∑ÂèñÂüüÂêçÁä∂ÊÄÅÂèòÂåñÂéÜÂè≤ÔºàÊ®°ÊãüÊï∞ÊçÆÔºåÂÆûÈôÖÂ∫îËØ•‰ªéÂéÜÂè≤Ë°®Ëé∑ÂèñÔºâ
  async getStatusHistory() {
    const sql = `
      SELECT 
        status,
        COUNT(*) as count
      FROM domains
      GROUP BY status
    `;

    return new Promise((resolve, reject) => {
      this.db.all(sql, [], (err, rows) => {
        if (err) {
          reject(err);
        } else {
          // ÁîüÊàêÊúÄËøë7Â§©ÁöÑÊ®°ÊãüÂéÜÂè≤Êï∞ÊçÆ
          const result = [];
          const today = new Date();
          
          for (let i = 6; i >= 0; i--) {
            const date = new Date(today);
            date.setDate(date.getDate() - i);
            const dateStr = date.toISOString().split('T')[0];
            
            const dayData = {
              date: dateStr,
              normal: rows.find(r => r.status === 'normal')?.count || 0,
              expiring: Math.max(0, (rows.find(r => r.status === 'expiring')?.count || 0) - Math.floor(Math.random() * 3)),
              expired: rows.find(r => r.status === 'expired')?.count || 0,
              failed: rows.find(r => r.status === 'failed')?.count || 0
            };
            result.push(dayData);
          }
          
          resolve(result);
        }
      });
    });
  }

  // Ëé∑ÂèñÊàêÊú¨ÁªüËÆ°ÔºàÊ®°ÊãüÊï∞ÊçÆÔºåÈúÄË¶ÅÂÆûÈôÖÊàêÊú¨Â≠óÊÆµÔºâ
  async getCostStats() {
    const sql = `
      SELECT 
        registrar,
        COUNT(*) as domainCount,
        -- ËøôÈáå‰ΩøÁî®Ê®°Êãü‰ª∑Ê†ºÔºåÂÆûÈôÖÂ∫îËØ•‰ªéÂüüÂêçË°®‰∏≠ÁöÑcostÂ≠óÊÆµËé∑Âèñ
        CASE registrar
          WHEN 'GoDaddy Inc.' THEN COUNT(*) * 12.99
          WHEN 'Namecheap, Inc.' THEN COUNT(*) * 10.99  
          WHEN 'Alibaba Cloud Computing Ltd. d/b/a HiChina' THEN COUNT(*) * 8.99
          WHEN 'DNSPod, Inc.' THEN COUNT(*) * 9.99
          ELSE COUNT(*) * 11.99
        END as totalCost
      FROM domains 
      WHERE registrar IS NOT NULL AND registrar != ''
      GROUP BY registrar
      ORDER BY totalCost DESC
    `;

    return new Promise((resolve, reject) => {
      this.db.all(sql, [], (err, rows) => {
        if (err) {
          reject(err);
        } else {
          const totalCost = rows.reduce((sum, row) => sum + row.totalCost, 0);
          const result = {
            byRegistrar: rows,
            totalCost: totalCost,
            averageCost: rows.length > 0 ? totalCost / rows.reduce((sum, row) => sum + row.domainCount, 0) : 0
          };
          resolve(result);
        }
      });
    });
  }

  // ËæÖÂä©ÊñπÊ≥ïÔºöÊ†ºÂºèÂåñÊúà‰ªΩ
  formatMonth(monthStr) {
    if (!monthStr) return '';
    const [year, month] = monthStr.split('-');
    const monthNames = [
      '1Êúà', '2Êúà', '3Êúà', '4Êúà', '5Êúà', '6Êúà',
      '7Êúà', '8Êúà', '9Êúà', '10Êúà', '11Êúà', '12Êúà'
    ];
    return `${year}Âπ¥${monthNames[parseInt(month) - 1]}`;
  }

  // ========== ËÆ§ËØÅÁõ∏ÂÖ≥ÊñπÊ≥ï ==========

  // Ëé∑ÂèñÊàñËÆæÁΩÆËÆøÈóÆÂØÜÁ†Å
  async setAuthConfig(key, value) {
    const sql = `
      INSERT OR REPLACE INTO auth_config (key, value, updated_at)
      VALUES (?, ?, CURRENT_TIMESTAMP)
    `;
    
    return new Promise((resolve, reject) => {
      this.db.run(sql, [key, value], function(err) {
        if (err) {
          reject(err);
        } else {
          resolve(this.lastID);
        }
      });
    });
  }

  // Ëé∑ÂèñËÆ§ËØÅÈÖçÁΩÆ
  async getAuthConfig(key) {
    const sql = `SELECT value FROM auth_config WHERE key = ?`;
    
    return new Promise((resolve, reject) => {
      this.db.get(sql, [key], (err, row) => {
        if (err) {
          reject(err);
        } else {
          resolve(row ? row.value : null);
        }
      });
    });
  }

  // ÂàõÂª∫Êñ∞‰ºöËØù
  async createSession(sessionId, ipAddress, userAgent, expiresAt) {
    const sql = `
      INSERT INTO auth_sessions (session_id, ip_address, user_agent, expires_at)
      VALUES (?, ?, ?, ?)
    `;
    
    return new Promise((resolve, reject) => {
      this.db.run(sql, [sessionId, ipAddress, userAgent, expiresAt], function(err) {
        if (err) {
          reject(err);
        } else {
          resolve(this.lastID);
        }
      });
    });
  }

  // È™åËØÅ‰ºöËØù
  async validateSession(sessionId) {
    const sql = `
      SELECT * FROM auth_sessions 
      WHERE session_id = ? AND expires_at > CURRENT_TIMESTAMP
    `;
    
    return new Promise((resolve, reject) => {
      this.db.get(sql, [sessionId], (err, row) => {
        if (err) {
          reject(err);
        } else {
          if (row) {
            // Êõ¥Êñ∞ÊúÄÂêéÊ¥ªÂä®Êó∂Èó¥
            this.updateSessionActivity(sessionId).catch(console.error);
          }
          resolve(row || null);
        }
      });
    });
  }

  // Êõ¥Êñ∞‰ºöËØùÊ¥ªÂä®Êó∂Èó¥
  async updateSessionActivity(sessionId) {
    const sql = `
      UPDATE auth_sessions 
      SET last_activity = CURRENT_TIMESTAMP 
      WHERE session_id = ?
    `;
    
    return new Promise((resolve, reject) => {
      this.db.run(sql, [sessionId], function(err) {
        if (err) {
          reject(err);
        } else {
          resolve(this.changes);
        }
      });
    });
  }

  // Âà†Èô§‰ºöËØùÔºàÁôªÂá∫Ôºâ
  async deleteSession(sessionId) {
    const sql = `DELETE FROM auth_sessions WHERE session_id = ?`;
    
    return new Promise((resolve, reject) => {
      this.db.run(sql, [sessionId], function(err) {
        if (err) {
          reject(err);
        } else {
          resolve(this.changes);
        }
      });
    });
  }

  // Ê∏ÖÁêÜËøáÊúü‰ºöËØù
  async cleanupExpiredSessions() {
    const sql = `DELETE FROM auth_sessions WHERE expires_at <= CURRENT_TIMESTAMP`;
    
    return new Promise((resolve, reject) => {
      this.db.run(sql, [], function(err) {
        if (err) {
          reject(err);
        } else {
          resolve(this.changes);
        }
      });
    });
  }

  // ËÆ∞ÂΩïÁôªÂΩïÂ∞ùËØï
  async recordLoginAttempt(ipAddress, success, captchaRequired = false) {
    const sql = `
      INSERT INTO login_attempts (ip_address, success, captcha_required)
      VALUES (?, ?, ?)
    `;
    
    return new Promise((resolve, reject) => {
      this.db.run(sql, [ipAddress, success, captchaRequired], function(err) {
        if (err) {
          reject(err);
        } else {
          resolve(this.lastID);
        }
      });
    });
  }

  // Ëé∑ÂèñÊúÄËøëÁôªÂΩïÂ§±Ë¥•Ê¨°Êï∞
  async getRecentFailedAttempts(ipAddress, minutesAgo = 15) {
    const sql = `
      SELECT COUNT(*) as count 
      FROM login_attempts 
      WHERE ip_address = ? 
        AND success = 0 
        AND attempt_time > datetime('now', '-${minutesAgo} minutes')
    `;
    
    return new Promise((resolve, reject) => {
      this.db.get(sql, [ipAddress], (err, row) => {
        if (err) {
          reject(err);
        } else {
          resolve(row ? row.count : 0);
        }
      });
    });
  }

  // Ê£ÄÊü•ÊòØÂê¶ÈúÄË¶ÅÈ™åËØÅÁ†Å
  async shouldRequireCaptcha(ipAddress) {
    const failedAttempts = await this.getRecentFailedAttempts(ipAddress);
    return failedAttempts >= 3; // 3Ê¨°Â§±Ë¥•ÂêéÈúÄË¶ÅÈ™åËØÅÁ†Å
  }

  // ÂàùÂßãÂåñÈªòËÆ§ËÆ§ËØÅÈÖçÁΩÆ
  async initializeAuthConfig() {
    try {
      // Ê£ÄÊü•ÊòØÂê¶Â∑≤ÁªèÊúâËÆøÈóÆÂØÜÁ†ÅÈÖçÁΩÆ
      const existingPassword = await this.getAuthConfig('access_password');
      if (!existingPassword) {
        // ËÆæÁΩÆÈªòËÆ§ÂØÜÁ†ÅÔºàÂª∫ËÆÆÁî®Êà∑È¶ñÊ¨°ÁôªÂΩïÂêé‰øÆÊîπÔºâ
        const crypto = await import('crypto');
        const defaultPassword = 'admin123'; // ÈªòËÆ§ÂØÜÁ†Å
        const hashedPassword = crypto.createHash('sha256').update(defaultPassword).digest('hex');
        await this.setAuthConfig('access_password', hashedPassword);
        
        // Ê†áËÆ∞‰∏∫Âº∫Âà∂‰øÆÊîπÂØÜÁ†ÅÔºàÈ¶ñÊ¨°‰ΩøÁî®ÈªòËÆ§ÂØÜÁ†ÅÔºâ
        await this.setAuthConfig('force_password_change', 'true');
        await this.setAuthConfig('password_created_at', new Date().toISOString());
        console.log('‚úÖ Â∑≤ËÆæÁΩÆÈªòËÆ§ËÆøÈóÆÂØÜÁ†Å: admin123 (È¶ñÊ¨°ÁôªÂΩïÈúÄÂº∫Âà∂‰øÆÊîπ)');
      }

      // ËÆæÁΩÆ‰ºöËØùËøáÊúüÊó∂Èó¥Ôºà24Â∞èÊó∂Ôºâ
      const sessionExpiry = await this.getAuthConfig('session_expiry_hours');
      if (!sessionExpiry) {
        await this.setAuthConfig('session_expiry_hours', '24');
      }

      // ËÆæÁΩÆÊúÄÂ§ßÁôªÂΩïÂ§±Ë¥•Ê¨°Êï∞
      const maxFailedAttempts = await this.getAuthConfig('max_failed_attempts');
      if (!maxFailedAttempts) {
        await this.setAuthConfig('max_failed_attempts', '5');
      }

      // ËÆæÁΩÆÂØÜÁ†ÅËøáÊúüÂ§©Êï∞Ôºà0Ë°®Á§∫‰∏çËøáÊúüÔºâ
      const passwordExpireDays = await this.getAuthConfig('password_expire_days');
      if (!passwordExpireDays) {
        await this.setAuthConfig('password_expire_days', '0'); // ÈªòËÆ§‰∏çËøáÊúü
      }

      // ËÆæÁΩÆÂº∫Âà∂‰øÆÊîπÂØÜÁ†ÅÁöÑÂéüÂõ†
      const forceChangeReason = await this.getAuthConfig('force_change_reason');
      if (!forceChangeReason) {
        await this.setAuthConfig('force_change_reason', '');
      }

    } catch (error) {
      console.error('‚ùå ÂàùÂßãÂåñËÆ§ËØÅÈÖçÁΩÆÂ§±Ë¥•:', error);
      throw error;
    }
  }

  // Ê£ÄÊü•ÊòØÂê¶ÈúÄË¶ÅÂº∫Âà∂‰øÆÊîπÂØÜÁ†Å
  async needsPasswordChange() {
    try {
      // Ê£ÄÊü•Âº∫Âà∂‰øÆÊîπÊ†áËÆ∞
      const forceChange = await this.getAuthConfig('force_password_change');
      if (forceChange === 'true') {
        return {
          required: true,
          reason: await this.getAuthConfig('force_change_reason') || 'È¶ñÊ¨°ÁôªÂΩïÈúÄË¶Å‰øÆÊîπÈªòËÆ§ÂØÜÁ†Å'
        };
      }

      // Ê£ÄÊü•ÂØÜÁ†ÅÊòØÂê¶ËøáÊúü
      const expireDays = await this.getAuthConfig('password_expire_days');
      if (expireDays && parseInt(expireDays) > 0) {
        const passwordCreatedAt = await this.getAuthConfig('password_created_at');
        if (passwordCreatedAt) {
          const createdDate = new Date(passwordCreatedAt);
          const expireDate = new Date(createdDate.getTime() + parseInt(expireDays) * 24 * 60 * 60 * 1000);
          
          if (new Date() > expireDate) {
            return {
              required: true,
              reason: `ÂØÜÁ†ÅÂ∑≤ËøáÊúü (${expireDays}Â§©)ÔºåËØ∑‰øÆÊîπÂØÜÁ†Å`
            };
          }
        }
      }

      return { required: false, reason: '' };
    } catch (error) {
      console.error('‚ùå Ê£ÄÊü•ÂØÜÁ†Å‰øÆÊîπÈúÄÊ±ÇÂ§±Ë¥•:', error);
      return { required: false, reason: '' };
    }
  }

  // ËÆæÁΩÆÂº∫Âà∂‰øÆÊîπÂØÜÁ†Å
  async setForcePasswordChange(reason = '') {
    try {
      await this.setAuthConfig('force_password_change', 'true');
      await this.setAuthConfig('force_change_reason', reason);
      console.log('‚úÖ Â∑≤ËÆæÁΩÆÂº∫Âà∂‰øÆÊîπÂØÜÁ†ÅÊ†áËÆ∞:', reason);
    } catch (error) {
      console.error('‚ùå ËÆæÁΩÆÂº∫Âà∂‰øÆÊîπÂØÜÁ†ÅÂ§±Ë¥•:', error);
      throw error;
    }
  }

  // Ê∏ÖÈô§Âº∫Âà∂‰øÆÊîπÂØÜÁ†ÅÊ†áËÆ∞
  async clearForcePasswordChange() {
    try {
      await this.setAuthConfig('force_password_change', 'false');
      await this.setAuthConfig('force_change_reason', '');
      await this.setAuthConfig('password_created_at', new Date().toISOString());
      console.log('‚úÖ Â∑≤Ê∏ÖÈô§Âº∫Âà∂‰øÆÊîπÂØÜÁ†ÅÊ†áËÆ∞');
    } catch (error) {
      console.error('‚ùå Ê∏ÖÈô§Âº∫Âà∂‰øÆÊîπÂØÜÁ†ÅÂ§±Ë¥•:', error);
      throw error;
    }
  }
}

// ÂàõÂª∫Âçï‰æãÂÆû‰æã
const db = new DomainDatabase();

export default db; 